import nltk
import tree_file
import NER_file
import calendar
from string import punctuation
from random import randint

def postprocess(text):
    if len(text) < 2: return None
    text = text.replace(" , ", ", ").replace(" '", "'").replace(" ?", "?").replace("  ", " ")
    text = text.replace("U .S .", "U.S.").replace("U . S", "U.S").replace("U.S .", "U.S.")
    text = text[0].upper() + text[1:]
    return text


def get_tokens(sentence):
    tokenized_text = nltk.word_tokenize(sentence)
    tagged = nltk.pos_tag(tokenized_text)
    return tagged

def detokenize(words):
    """
    This line of code is borrowed from https://stackoverflow.com/questions/21948019/python-untokenize-a-sentence
    it intends to de-tokenize the tokens generated by nltk
    """
    return "".join([" "+i if not i.startswith("'") and i not in punctuation else i for i in words]).strip()

def askBinary(sent, raw_tree, persons, orgs):

    tokens = get_tokens(sent)
    if raw_tree[0][0].label() == "PP":
        pp = raw_tree[0][0]
        merged_pp = tree_file.merge_raw_tree(pp)
        sent = sent.replace(merged_pp, "").strip(";. ")
        sections = sent.split(",", maxsplit=1)
        if len(sections) > 1:
            if sections[0] != '' and sections[0][0] != ",":
                merged_pp += " "
            merged_pp += sections[0]
            sent = sections[1]

        if pp[0].label() == "IN":
            merged_pp = merged_pp[0].lower() + merged_pp[1:]
        raw_tree = tree_file.generateTree(sent)
        merged_pp = " " + merged_pp
    else:
        merged_pp = ""

    question = tree_file.get_qbody(raw_tree, persons, orgs)
    if not question:
        return None
    question = question + merged_pp + "?"
    tweak = randint(0, 1)
    numeric_words = [
        "two", "three", "four", "five", 
        "six", "seven", "eight", "nine", "ten", 
        "eleven", "twelve", "thirteen", "fourteen", "fifteen", 
        "sixteen", "seventeen", "nineteen", "twenty"
    ]
    numeric_words_dict = {word: idx for idx, word in enumerate(numeric_words)}
    if tweak:
        words = nltk.word_tokenize(question)
        for idx, word in enumerate(words):
            if word in calendar.month_name:
                words[idx] = calendar.month_name[randint(1, 12)]
                break
            elif word in calendar.month_abbr:
                words[idx] = caldendar.month_abbr[randint(1, 12)]
                break
            elif word.isdigit():
                num = int(word)

                # avoid invalid dates
                if 0 <= num < 28:
                    words[idx] = str(num+1)
                    break
                elif num <= 31:
                    words[idx] = str(num-1)
                    break
                else:
                    words[idx] = str(num+1)
                    break
            elif word.lower() in numeric_words_dict:
                words[idx] = numeric_words[numeric_words_dict[word.lower()]+1%19]
                break
        question = detokenize(words)
    if not question: return None
    return postprocess(question)

def belongs_to(subject, category):
    if not subject:
        return None
    leaves = subject.leaves()
    if not leaves:
        return None
    return len(leaves) >= 2 and leaves[1] in category or leaves[0] in category

def askSubject(sent, raw_tree, ner_tree, persons, orgs):
    '''
    def is_person(subject):
        if subject == None:
            return False
        if type(subject) == nltk.Tree:
            return subject.label() == "PERSON"
        return subject[0].label() == "PRP" and subject[0][0].lower() != "it"
    '''

    subject, action = tree_file.find_subject_action(raw_tree)
    if subject == None or not action: return None
    if belongs_to(subject, persons):
        question = "Who " + tree_file.merge_raw_tree(action) + "?"
        return postprocess(question)
    elif belongs_to(subject, orgs):
        question = "What organization " + tree_file.merge_raw_tree(action) + "?"
        return postprocess(question)
    else: # default
        question = "What " + tree_file.merge_raw_tree(action) + "?"
        return postprocess(question)

def askWhen(sent, raw_tree, ner_tree, persons, orgs):
    dates = []
    for st in ner_tree:
        if type(st) != nltk.Tree:
            continue

        if st.label() == "DATE":
            #find all dates from the ner_tree
            dates.append(tree_file.merge_ner_tree(st))
    if not dates:
        return None

    pps = tree_file.get_phrases(raw_tree, "PP")

    for pp in pps:
        # remove all dates in the original sentence
        merged_pp = tree_file.merge_raw_tree(pp)
        has_date = False
        for d in dates:
            if d in merged_pp:
                has_date = True
                break
        if has_date: 
            sent = sent.replace(merged_pp, "").strip(",;. ")

    # reconstruct the tree after removing all dates
    raw_tree = tree_file.generateTree(sent)
    qbody = tree_file.get_qbody(raw_tree)
    if not qbody:
        return None
    return postprocess("When " + tree_file.get_qbody(raw_tree) + "?")

def askWhere(sent, raw_tree, ner_tree, persons, orgs):
    locations = []
    dates = []
    for st in ner_tree:
        if type(st) != nltk.Tree: continue
        if st.label() == "LOCATION":
            locations.append(tree_file.merge_ner_tree(st))
        if st.label() == "DATE":
            dates.append(tree_file.merge_ner_tree(st))

    if not locations:
        return None
    pps = tree_file.get_phrases(raw_tree, "PP")
    prep = None
    for pp in pps:
        merged_pp = tree_file.merge_raw_tree(pp)
        has_location = False
        for l in locations:
            if l in merged_pp:
                has_location = True
                prep = pp.leaves()[0]
                if prep.lower() not in ("in", "at", "on", "from"):
                    return None
                break
        if has_location:
            sent = sent.replace(merged_pp, "").strip(",;. ")
    if prep is None:
        return None
    for pp in pps:
        merged_pp = tree_file.merge_raw_tree(pp)
        for d in dates:
            if d in merged_pp:
                sent = sent.replace(merged_pp, "").strip(",;. ")

    raw_tree = tree_file.generateTree(sent)
    qbody = tree_file.get_qbody(raw_tree)
    if not qbody:
        return None
    if prep.lower() != "from":
        prep = ""
    return postprocess("Where " + tree_file.get_qbody(raw_tree) + " " + prep + "?")

